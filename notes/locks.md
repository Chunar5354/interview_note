## 乐观锁

总是假设最好的情况，即认为`不会有别人对数据进行修改`，所以每次`取`数据都`不会加锁`，而是在`更新`数据时判断在此期间`是否被修改过`

可以通过CAS算法和MVCC机制实现

### CAS算法

[参考](https://segmentfault.com/a/1190000021653471)

Compare And Swap，比较并交换

CAS是无锁算法，有三个参数，原位置的值V，旧的预期值A，要更新的值B

操作流程如下：

- 1.从原位置备份一个数据（旧的预期值A）

- 2.进行一系列操作后计算出要更新的值B

- 3.判断当前的`原位置的值V和预期值A是否相等`，如果相等说明在此期间这个值`没有被其它程序修改过`，就将V更新为B，如果不相等说明`被修改过`，操作失败

#### CAS的缺点

- ABA问题，因为判断的是值相等，如果某个值由A改为B又由B改为了A，那么将判断为未改变，但实际上改变了

解决方法：使用`版本号`，不再判断值是否相等，而是判断事务的版本号和数据的版本号是否相等

- 循环时间长，如果更新不成功，会`自旋循环`反复尝试，造成CPU开销过大

解决方法：设置循环次数或超时时间

- 只能保证一个共享变量的原子操作

解决方法：使用锁，或将多个变量合并成一个变量

## 悲观锁

总是假设最坏的情况，即在操作期间`一定会有其他人来修改数据`，所以`每次`取数据都会`加锁`

## 共享锁

多个事务对于同一个事务可以共享一把锁，典型应用：读锁

## 排他锁

如果一个事务获得了数据的排他锁，其他事务就不能获得关于这个数据的`任何锁`

## Mysql中的共享锁与排他锁

在Mysql的Innodb中，默认对update, insert, delete加排他锁，select默认不加任何锁

如果想对select加排他锁，可以使用

```sql
select ... for update
```

如果想对select加共享锁，可以使用

```sql
select ... lock in share mode
```