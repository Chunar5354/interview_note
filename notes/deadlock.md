死锁的产生有四个`必要`条件：

- 1.互斥，某些资源不能同时访问

- 2.持有并等待， 一个线程在等待其他资源是不释放本身持有的资源

- 3.非抢占，其它线程不能抢占某个线程持有的资源

- 4.循环等待，比如A依赖B的资源、B依赖C，C依赖A，存在这样的闭环

死锁有4中处理方法

### 死锁预防

破坏四个必要条件中的一个

- 互斥，一般难以改变

- 持有并等待，可以要求线程必须`一次性`申请到所有需要的资源，否则就等待

- 非抢占，分为`主动释放`和操作系统`强行调度`

- 循环等待，定义资源申请必须按照某种`线性顺序`

### 死锁避免

两种死锁避免算法：

- 1.进程启动拒绝，如果一个进程的请求会导致死锁，则不启动该进程

- 2.资源分配拒绝，如果一个进程请求分配的资源会导致死锁，就不分配（银行家算法）

#### 银行家算法

类似银行借贷的思想，在分配资源前首先判断总的资源是否足够为新进程分配，如果足够，就假设分配，并判断是否处于`安全状态`（能够按照某种顺序为每个进程分配资源）

### 死锁检测

为每个资源和进程编号，检测是否有环

### 死锁恢复

强制挂起某些死锁进程（按照优先级、运行时间、资源占用量等顺序）
