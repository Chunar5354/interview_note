## shell

shell意为`壳`，是用户与内核进行交互的渠道

### $变量

- `$#`表示参数个数

- `$0`脚本名

- `$1`传给脚本的第一个参数

- `$2`传给脚本的第二个参数

- `$$`脚本运行的当前`进程ID`

- `$?`脚本运行的返回值，当运行成功时值为0，否则为1

### shell命令的返回

shell命令在运行后会返回一个`$?`变量，当运行成功时值为0，否则为1

可以在运行命令后查看

```
$ echo $?
```

## Linux常用shell命令

### 查看cpu信息

```
$ cat /proc/cpuinfo
```

### 查看内存信息

```
$ cat /proc/meminfo
```

或

```
$ free
```

free可以带参数，`-k`, `-m`, `-g`分别表示以KB，MB和GB为单位来表示内存大小

### 查看系统版本

```
$ uname -a
或
$ lsb_release
```

### 查看网络适配器

```
$ ip a
```

### 查看系统负载

```
$ top
```

top可以带参数，常用的`-d`表示每隔多少秒刷新一次，`-p`表示查看某个进程PID，`-c`表示显示进程的命令行参数

如

```
$ top -d 3 -c -p 18690
```

top输出中`load average`的含义：在过去1分钟、5分钟和15分钟内的CPU平均负载

如`load average: 0.12 0.22 0.13`表示过去一分钟内在CPU运行或等待运行的`平均进程数`，以此类推，每个CPU同时只能运行一个进程，所以当数字`超过CPU核数`时，说明系统负载过高（通常为核心数*0.7以下）

### 查看系统日志

```
$ dmesg
或
$ dmesg | tail   // 只输出日志的最后10行
```

### 查看文件大小

```
$ du
```

du默认会按照字节数打印出当前目录下所有子目录中文件的大小，有更友好的方式

```
$ du -h --max-depth=1
```

`-h`表示human-readable，即用户友好的方式，它会以常用的KB，MB等单位打印出文件大小

`--max-depth=1`表示只统计当前目录下`一层`的文件（文件夹）大小，不会向下深入统计

### 数据流重定向

通过`>`和`<`可以将`标准输入和输出`的数据重定向到`文件`

`>`意为将`标准输出`重定向到文件(`写入`)，如

```
$ ls > test.txt
```

就会在当前目录下新建一个text.txt文件，并将ls的结果写入文件，而不会在命令行中打印结果

`<`意为将`文件`的数据重定向到`标准输入`(`读取`)

如

```
$ cat > test1 < test2
```

就会将test2文件中的内容输入到test1（相当于复制）

从左到右执行，首先遇到`cat > test`，需要将标准输出（默认由`键盘输入`）的值写入到test1文件，然后遇到`< test2`，将test2文件的内容重定向到了标准输入，于是就将test2的内容复制到了test1

`<`与`>`是覆盖模式，会删除文件中原本的内容，如果想要保留文件的内容，可以使用`>>`或`<<`的追加模式，它们会在文件的末尾继续添加内容

### 修改权限

修改文件（文件夹）的权限通过`chmod`实现，如

```
$ chmod 755 testfile
```

那755这三个数字分别代表什么意思呢？

在Linux系统中，文件有三种权限，读（r），写（w）和执行（x），通过`ls -l`命令可以看到

```
$ ls -l | grep test
drwxr-xr-x 2 chunar chunar 4096 May 22 09:11 test
```

其中每一种权限都对应一个`权限数值`，`r=4`, `w=2`, `x=1`，因为都是2的n次方，所以它们任意组队的和都是`唯一的`，所以可以通过数字来表示文件具有哪些权限：

```
7 = 4 + 2 + 1, 权限：rwx
6 = 4 + 2,     权限：rw-
5 = 4 + 1,     权限：r-x
4 = 4,         权限：r--
3 = 2 + 1,     权限：-wx
2 = 2,         权限：-w-
1 = 1,         权限：--x
```

在ls -l命令的输出中，表示权限的字符串为`drwxr-xr-x`，第一个d表示是一个文件夹，后面的rwx组合共有三组，从左到右依次表示`文件所有者`，`群组用户`，`其他用户`所拥有的权限

