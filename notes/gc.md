[参考](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)

## 内存管理

C，C++和Rust等语言使用手动方式管理内存

Python，Ruby，Java和Go等语言使用自动的内存管理系统，通常是`垃圾收集机制`

## 垃圾收集

早期的垃圾收集需要暂停程序（Stop The World，STW）

### 标记清除法

跟踪式垃圾收集器，执行过程发呢为标记和清除两阶段

- 1.标记阶段，从`根对象`出发查找并标记所有存活的对象

- 2.清楚阶段，遍历堆中的全部对象，回收`未被标记`的垃圾对象并将回收的内存加入`空闲链表`

在这两个阶段中，用户程序都`不能执行`

### 三色标记法

三色标记法可以`缩短STW的时间`

将程序中的对象分为黑色，白色和灰色

- 黑色：活跃的对象，`不存在任何引用外部指针`的对象，以及从根对象`可达`的对象

- 灰色：活跃的对象，存在指向白色对象的外部指针

- 白色：潜在的垃圾对象

最开始全是`白色对象`，首先将`根对象标记成灰色`，然后按照以下步骤：

- 1.从灰色集合中选择一个对象标记为`黑色`

- 2.将黑色对象指向的所有对象都标记为`灰色`

- 3.重复1和2直到`没有灰色对象存在`

标记结束之后，就只有黑白对象，白色是要被清除的垃圾对象

由于用户在标记过程中可能修改指针，所以三色标记法也需要STW，为了`并发地标记对象`需要使用`屏障技术`

### 屏障技术

仅仅通过三色标记法不能保证并发的安全性，比如下面这种情况：

[![RSVE7Q.png](https://z3.ax1x.com/2021/06/18/RSVE7Q.png)](https://imgtu.com/i/RSVE7Q)

在阶段1，灰色对象B指向白色对象C，但在继续标记前，其它的进程断开了BC之间的引用，而将黑色对象A指向了D，因为标记阶段只会在灰色对象开始，所以C与D不会被遍历到，最终仍然是白色，导致被错误回收

为了避免这种类似情况，golang采用了`写屏障`技术

因为现代处理器都`乱序执行指令`，屏障技术可以保证内存操作的顺序性，在内存屏障前执行的操作`一定早于`内存屏障执行后的操作

为了并发的标记，需要满足两种`三色不变性`中的一种:

- 1.强三色不变性，黑色对象不会指向白色对象

- 2.弱三色不变性，黑色对象可以指向白色对象，但指向的白色对象必须包含一条从灰色对象经由多个白色对象的`可达`路径

屏障技术分为读屏障和写屏障，读屏障需要在读操作中加入代码片段，影响用户程序性能，所以主要用`写屏障`来`保证三色不变性`

写屏障主要有Dijkstra插入写屏障和Yuasa删除写屏障

- 插入写屏障

插入写屏障发生在`用户创建`对象引用之前，如果新的被引用的对象是白色的，就将新对象标记成`灰色`

插入写屏障是将所有可能存活的对象都标记成灰色以满足`强`三色不变性

对于前面介绍的场景，如果应用插入写屏障，则变成：

[![RSVJAJ.png](https://z3.ax1x.com/2021/06/18/RSVJAJ.png)](https://imgtu.com/i/RSVJAJ)

保证了黑色对象A不会指向白色对象，D就可以被遍历到

- 删除写屏障

删除写屏障发生在`用户删除`对象引用之后，如果旧的被引用的对象是白色，将这个旧的被引用对象标记成灰色

因为原来的引用断掉了，所以将新的起始对象标记成灰色，能够保证`弱`三色不变性（即这个旧对象后面引用的白色对象都能够由灰色对象可达）

对于前面的场景，如果应用删除写屏障，则变成：

[![RSVc4A.png](https://z3.ax1x.com/2021/06/18/RSVc4A.png)](https://imgtu.com/i/RSVc4A)

在删除BC的引用时，将被删除的C标记成灰色，这样在下次标记时，C就可以被遍历到，而对于被黑色对象A指向的白色对象D，它能够由灰色对象C可达，而保证了弱三色不变性

屏障技术可能造成本应该被回收的对象（白色）被`错误标记成黑色`（上面例子中的C）

目前go'语言应用`混合写屏障`，即二者结合

### 增量与并发

使用增量和并发方式可以使用户程序与垃圾收集器`交替运行`，需要用到屏障技术来保证正确性

- 增量式垃圾收集器将原本较长的暂停时间切分成较小的`时间片`，它能`减少`最长暂停时间，但`增加`了一次GC循环的总时间

- 并发式垃圾收集器利用`多核并行`执行垃圾收集与用户程序，它能`同时减少`最长暂停时间和GC收集的总时间

### 垃圾收集流程

4个阶段：

- 1.标记准备（清理终止）阶段，暂停程序，所有处理器进入`安全点`

- 2.标记阶段

- 3.标记终止阶段，暂停程序

- 4.清理阶段

### 触发方式

3种触发方式

- 1.后台定时调用（runtime.gcStart）

- 2.手动触发（runtime.GC）

- 3.申请新内存时触发（runtime.mallocgc）
