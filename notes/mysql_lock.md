# 全局锁

全局锁会锁住整个库，一般在进行`备份`时使用

命令：

```
Flush tables with read lock
```

FTWRL这种方式主要用于不支持事务的引擎备份

在Innodb引擎下，使用mysqldump进行备份时会先开启一个事务，通过`MVCC`机制来保证在当前备份（其实就是select出整个库的数据到文件）事务下数据的一致性

# 表级锁

mysql的表级锁包括`表锁`和`元数据锁`

## 表锁

表锁的命令：

```
lock tables t1 read/write, t2 read/write...
```

之后可以通过`unlock tables`来解锁

表锁除了会限制其它线程的操作，也会`限制当前线程`的操作

如执行：

```
lock tables t1 read, t2 write;
```

则其它线程对于t1的写操作，对t2的读写操作都会被阻塞

而当前线程只能对t1进行读，而`不能写`（因为其它线程可能会读），可以对t2进行读写

## 元数据锁

元数据锁（Metadata Lock，MDL）不需要显式使用，会在访问表的时候`自动添加`

MDL是为了保证表的正确性，在一个线程访问表的时候，其他线程`不能修改表结构`（比如增加一个字段）

因为MDL的存在，所以在为表添加字段的时候，可能导致大量阻塞

为此，在添加字段时，可以尝试先kill前面的事务，或者为alter语句增加`wait n`超时时间

# 行级锁

行级锁仅在InnoDB引擎中支持

行锁是加在`索引`上的，而且只有`访问到`的对象才会加锁（比如对于普通索引的覆盖索引查询，由于不需要经过主键，所以不会给主键加锁）

## Record lock

在`单条记录`上加锁，锁住的是`索引`，而非记录本身，如果表上没有索引，innodb会创建隐藏的`rowid`作为主键聚合索引

rowid只在两种情况下可见（因为此时不需要rowid来唯一区分记录了）：

- 1.有主键且主键类型为整数

- 2.没有主键但有唯一索引，且类型为整数

## Gap lock

间隙锁，在索引记录之前或之后加锁，并`不包括索引记录本身`

Gap锁解决了`当前读`中的幻读问题

在可重复读级别下，产生间隙锁的条件：

- 1.使用`普通索引`

- 2.使用`多列唯一索引`

- 3.使用唯一索引`锁定多行记录`（范围）

间隙锁锁住的间隙是开区间

### 当前读

当前读会在所有扫描的索引记录上`加锁`，如：

- insert

- update

- delete

- select ... lock in share mode

- select ... for update

### 快照读

简单的select语句使用快照读，`不加锁`，也不会阻塞

通过undo log和MVCC机制避免幻读

## Next-key lock

Record lock与Gap lock的结合，处理记录的时候，不但锁住当前的索引，也锁住相邻的索引

是mysql`可重复读`级别下的默认锁

为减少行锁的竞争，在一个事务中，尽量把`更新操作放在后面`

next-key lock锁住的是`左开右闭`区间

## 意向锁

意向锁主要用于`多种粒度锁并存`的情况，如：

事务A为表中的某几条记录加上了`行锁`，而事务B想要给表加上`表锁`，为了判断表当前是否处于锁定状态，事务B要`遍历每一行`来确定是否存在行锁，这样效率很低

如果使用意向锁，事务A就在更新一条记录之前，先加意向锁，再加X锁，事务B到来的时候，只需要检查表上的意向锁是否与自己冲突，而无需直到具体哪一行被上锁，省去了遍历的开销