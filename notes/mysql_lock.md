InnoDB引擎中的几种锁

## Record lock

在`单条记录`上加锁，锁住的是`索引`，而非记录本身，如果表上没有索引，innodb会创建隐藏的`rowid`作为主键聚合索引

rowid只在两种情况下可见（因为此时不需要rowid来唯一区分记录了）：

- 1.有主键且主键类型为整数

- 2.没有主键但有唯一索引，且类型为整数

## Gap lock

间隙锁，在索引记录之前或之后加锁，并`不包括索引记录本身`

Gap锁解决了`当前读`中的幻读问题

### 当前读

当前读会在所有扫描的索引记录上`加锁`，如：

- insert

- update

- delete

- select ... lock in share mode

- select ... for update

### 快照读

简单的select语句使用快照读，`不加锁`，也不会阻塞

通过undo log和MVCC机制避免幻读

## Next-key lock

Record lock与Gap lock的结合，处理记录的时候，不但锁住当前的索引，也锁住相邻的索引

是mysql`可重复读`级别下的默认锁

## 意向锁

意向锁主要用于`多种粒度锁并存`的情况，如：

事务A为表中的某几条记录加上了`行锁`，而事务B想要给表加上`表锁`，为了判断表当前是否处于锁定状态，事务B要`遍历每一行`来确定是否存在行锁，这样效率很低

如果使用意向锁，事务A就在更新一条记录之前，先加意向锁，再加X锁，事务B到来的时候，只需要检查表上的意向锁是否与自己冲突，而无需直到具体哪一行被上锁，省去了遍历的开销