## Python中的GC

Python的垃圾回收采用的是`引用计数法`

### 引用计数法

在Python中，每个对象的核心是一个PyObject结构体，每个对象会维护一个`ob_refcnt`表示被引用的次数，当某个对象的引用计数值为0时，它就会被回收

计数增加的情况：

- 1.对象被创建时, a=1

- 2.对象被其他对象引用的时候, b=a

- 3.对象作为参数被调用时, f(a)

- 4.对象被存储进容器时, l = [a]

计数减少的情况：

- 1.对象名被销毁, del a

- 2.对象名被赋予新的对象, a=Ob1()

- 3.函数调用结束，对象离开作用域

- 4.对象所在的容器被销毁，或从容器中删除对象, del l, l.pop()

引用计数法的优点：

- 1.高效，某个对象的引用为0可以直接释放，不用等待特定的时机

缺点：

- 1.需要分配单独的空间来维护引用计数

- 2.循环引用

### 如何解决循环引用

引用计数法本身对于循环引用是无解的，需要引入`标记清除法`作为辅助

标记清除法维护两个集合，`待扫描`与`不可达`

假设有A，B，C三个对象，A引用了B，B引用了C，C引用了A，是一个循环引用

[![Whfd3T.png](https://z3.ax1x.com/2021/07/27/Whfd3T.png)](https://imgtu.com/i/Whfd3T)

在标记清除的开始阶段，三个对象都在待扫描集合中，且引用计数都为1

在标记阶段遍历待扫描集合中的对象，并将它的引用计数减一，然后将为0的对象添加到不可达集合中

这样在标记阶段结束之后，A，B，C都被标记为不可达，可以回收

如果是另一种情况，假设A除了循环引用之后还有一个外部引用

[![WhhFP0.png](https://z3.ax1x.com/2021/07/27/WhhFP0.png)](https://imgtu.com/i/WhhFP0)

此时A的引用计数是2，B与C的计数是1，所以在标记阶段结束之后，A仍是可达（计数为1），B与C为不可达

然后GC会`从可达的对象出发`，将所有能够访问到的对象（相连的对象）都标记为可达，所以在这种情况下，B与C最终也会被标记为可达，不会被回收

标记清除法会`暂停程序`，为了减少暂停时间，可以采用分代回收的策略

### 分代回收

分代方法的主要思想是一个对象存在的时间越长，是垃圾的可能性越小

将所有对象分为老年代（2）、中年代（1）、年轻代（0）三代（三个链表）

新生的对象被放到第0代，如果它存货过了一次GC，就被放到第1代，类似的，存活的第1代会被放到第2代

每一代GC的`频率`是不同的，第0代最高，第2代最低

### CG触发的时机

- 1.手动调用gc.collect()

- 2.程序退出

- 3.设置每一代GC触发的阈值：

上一次第0代GC后，如果分配的对象个数减去释放对象的个数大于threshold0，就对第0代GC

上一次第1代GC后，如果`第0代`被GC的次数大于threshold1，就`对第1代`GC

上一次第2代GC后，如果`第1代`被GC的次数大于threshold2，就`对第2代`GC
