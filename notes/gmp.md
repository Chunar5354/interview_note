[参考](https://learnku.com/articles/41728)

## 为什么需要调度器

为了提高并发能力，同时运行多个进程（线程，协程）

进程具有大量的上下文资源，切换时开销很大

线程开销相对较小，但是多线程共用一个进程的虚拟地址空间，会发生竞争、锁等问题

把线程分为用户态和内核态，内核态的线程仍然由CPU调度，用户态的线程(协程)由`用户程序自行调度`，这样就减轻了CPU的负担

用户态的协程与内核态的线程时`M:N`的关系

## GMP模型

G(goroutine)协程，每个G是结构体，G只有被保存到P之后才能被调度运行

M(Mcahine)内核线程，M`不保存G的上下文`，所以G可以跨M

P(Processor)处理器

**本质上是P作为缓存来将G放到M上运行**

G有全局队列，每个P还有一个本地队列用来存放G，当新出现G的时候，优先放到P的`本地队列`中，P的数量可以通过`GOMAXPROCS`来设置，默认是`CPU核心数`

P和M的数量没有绝对的关系，当M阻塞时，P就会创建新的M（所以`M可能比P多`）

### GMP的优势

- 轻量调度

M在全局队列获取G的时候需要加锁，而在P的本地队列获取G则`不需要加锁`

- 复用线程

work stealing机制，当本线程没有可运行的G时，会尝试从其他线程绑定的P`偷取G`，而不是销毁当前线程

hand off机制，当本线程被阻塞时（因为G的系通过调用），释放绑定的P，交给其他空闲的线程
